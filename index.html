<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="Interactive visualizations of beautiful mathematical objects - Lorenz attractor, Möbius strip, Klein bottle, Sierpinski triangle, and Mandelbrot set.">
<meta name="theme-color" content="#101010">
<meta property="og:type" content="website">
<meta property="og:title" content="Math Visualizations - Interactive Mathematical Art">
<meta property="og:description" content="Explore chaos theory, topology, and fractals through interactive browser-based visualizations.">
<link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>∞</text></svg>">
<title>Math Visualizations</title>
<link rel="stylesheet" href="css/shared.css">
<style>
.landing-header {
    padding: 64px 0 48px;
    text-align: center;
    border-bottom: 1px solid var(--border);
}
.landing-header h1 {
    font-family: var(--font-body);
    font-size: 2.6rem;
    font-weight: 400;
    letter-spacing: 0.5px;
    color: #eee;
    margin-bottom: 12px;
}
.landing-header .tagline {
    font-size: 1.05rem;
    color: var(--text-dim);
    font-style: italic;
    max-width: 520px;
    margin: 0 auto;
}
.viz-grid {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 24px;
    max-width: 820px;
    margin: 48px auto;
    padding: 0 28px;
}
.viz-card {
    background: var(--bg-surface);
    border: 1px solid var(--border);
    border-radius: 8px;
    overflow: hidden;
    text-decoration: none;
    color: inherit;
    transition: border-color 0.25s, transform 0.25s;
    display: block;
}
.viz-card:hover {
    border-color: var(--accent);
    transform: translateY(-3px);
}
.viz-thumb {
    width: 100%;
    height: 180px;
    display: block;
    background: var(--bg);
}
.viz-card-body {
    padding: 20px 22px;
}
.viz-tag {
    font-family: var(--font-ui);
    font-size: 0.7rem;
    text-transform: uppercase;
    letter-spacing: 2px;
    color: var(--accent);
}
.viz-card-body h3 {
    font-family: var(--font-body);
    font-weight: 400;
    font-size: 1.3rem;
    color: #eee;
    margin: 8px 0;
}
.viz-card-body p {
    font-size: 0.88rem;
    color: var(--text-dim);
    line-height: 1.6;
}
.landing-footer {
    text-align: center;
    padding: 32px 0 48px;
    font-family: var(--font-ui);
    font-size: 0.8rem;
    color: var(--text-dim);
}
@media (max-width: 600px) {
    .landing-header { padding: 48px 0 36px; }
    .landing-header h1 { font-size: 1.8rem; }
    .viz-grid {
        grid-template-columns: 1fr;
        padding: 0 20px;
    }
}
</style>
</head>
<body>

<div class="container">
<div class="landing-header">
    <h1>Math Visualizations</h1>
    <p class="tagline">An interactive collection of mathematical objects, rendered in the browser</p>
</div>
</div>

<div class="viz-grid">

    <a href="visualizations/lorenz.html" class="viz-card">
        <canvas class="viz-thumb" id="thumb-lorenz"></canvas>
        <div class="viz-card-body">
            <span class="viz-tag">Chaos Theory</span>
            <h3>Lorenz Attractor</h3>
            <p>The butterfly of chaos. A 3D shape born from weather equations where tiny differences lead to wildly different outcomes</p>
        </div>
    </a>

    <a href="visualizations/mobius.html" class="viz-card">
        <canvas class="viz-thumb" id="thumb-mobius"></canvas>
        <div class="viz-card-body">
            <span class="viz-tag">Topology</span>
            <h3>Mobius Strip</h3>
            <p>A surface with only one side and one edge. Twist a strip and connect the ends</p>
        </div>
    </a>

    <a href="visualizations/klein.html" class="viz-card">
        <canvas class="viz-thumb" id="thumb-klein"></canvas>
        <div class="viz-card-body">
            <span class="viz-tag">Topology</span>
            <h3>Klein Bottle</h3>
            <p>A closed surface with no inside or outside. It can only truly exist in four dimensions</p>
        </div>
    </a>

    <a href="visualizations/sierpinski.html" class="viz-card">
        <canvas class="viz-thumb" id="thumb-sierpinski"></canvas>
        <div class="viz-card-body">
            <span class="viz-tag">Fractal</span>
            <h3>Sierpinski Triangle</h3>
            <p>Infinite self-similarity from a simple rule: remove the middle, repeat forever</p>
        </div>
    </a>

    <a href="visualizations/mandelbrot.html" class="viz-card">
        <canvas class="viz-thumb" id="thumb-mandelbrot"></canvas>
        <div class="viz-card-body">
            <span class="viz-tag">Fractal</span>
            <h3>Mandelbrot Set</h3>
            <p>Infinite complexity from the simplest equation: z squared plus c, iterated forever</p>
        </div>
    </a>

</div>

<div class="landing-footer">
    Built with vanilla HTML, CSS, and JavaScript
</div>

<script>
// =====================================================================
// Thumbnail renderers — small programmatic previews for each card.
// No image files needed; each canvas draws a simplified version.
// =====================================================================

(function () {
    'use strict';

    var ACCENT = '#c8a26a';
    var ACCENT_DIM = 'rgba(200, 162, 106, 0.6)';
    var BG = '#101010';

    function setupCanvas(id) {
        var c = document.getElementById(id);
        if (!c) return null;
        var dpr = window.devicePixelRatio || 1;
        var rect = c.getBoundingClientRect();
        var w = rect.width || 380;
        var h = rect.height || 180;
        c.width = w * dpr;
        c.height = h * dpr;
        var ctx = c.getContext('2d');
        ctx.scale(dpr, dpr);
        ctx.fillStyle = BG;
        ctx.fillRect(0, 0, w, h);
        return { ctx: ctx, w: w, h: h, dpr: dpr };
    }

    // --- Lorenz: 2D projection (XZ plane) ---
    function drawLorenz() {
        var s = setupCanvas('thumb-lorenz');
        if (!s) return;
        var ctx = s.ctx, w = s.w, h = s.h;

        var SIGMA = 10, RHO = 28, BETA = 8 / 3, DT = 0.005;
        var x = 0.1, y = 0, z = 0;
        var pts = [];
        for (var i = 0; i < 8000; i++) {
            var dx = SIGMA * (y - x) * DT;
            var dy = (x * (RHO - z) - y) * DT;
            var dz = (x * y - BETA * z) * DT;
            x += dx; y += dy; z += dz;
            pts.push([x, z]);
        }

        // Scale to canvas
        var minX = -25, maxX = 25, minZ = 0, maxZ = 50;
        ctx.strokeStyle = ACCENT;
        ctx.lineWidth = 0.8;
        ctx.globalAlpha = 0.7;
        ctx.beginPath();
        for (var i = 0; i < pts.length; i++) {
            var px = ((pts[i][0] - minX) / (maxX - minX)) * (w - 40) + 20;
            var py = h - ((pts[i][1] - minZ) / (maxZ - minZ)) * (h - 30) - 15;
            if (i === 0) ctx.moveTo(px, py);
            else ctx.lineTo(px, py);
        }
        ctx.stroke();
        ctx.globalAlpha = 1;
    }

    // --- Mobius: wireframe strip ---
    function drawMobius() {
        var s = setupCanvas('thumb-mobius');
        if (!s) return;
        var ctx = s.ctx, w = s.w, h = s.h;
        var cx = w / 2, cy = h / 2;
        var R = Math.min(w, h) * 0.3;
        var W_STRIP = R * 0.35;

        ctx.strokeStyle = ACCENT;
        ctx.lineWidth = 1;
        ctx.globalAlpha = 0.7;

        // Draw edge curves
        for (var edge = -1; edge <= 1; edge += 2) {
            ctx.beginPath();
            for (var i = 0; i <= 200; i++) {
                var u = (i / 200) * 2 * Math.PI;
                var v = edge * W_STRIP;
                var r = R + v * Math.cos(u / 2);
                var x3d = r * Math.cos(u);
                var y3d = r * Math.sin(u);
                var z3d = v * Math.sin(u / 2);
                // Simple isometric projection
                var px = cx + x3d * 0.7 - y3d * 0.3;
                var py = cy - z3d * 0.9 - y3d * 0.3;
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.stroke();
        }

        // Cross-ribs
        ctx.globalAlpha = 0.25;
        for (var i = 0; i < 24; i++) {
            var u = (i / 24) * 2 * Math.PI;
            ctx.beginPath();
            for (var j = -1; j <= 1; j += 0.2) {
                var v = j * W_STRIP;
                var r = R + v * Math.cos(u / 2);
                var x3d = r * Math.cos(u);
                var y3d = r * Math.sin(u);
                var z3d = v * Math.sin(u / 2);
                var px = cx + x3d * 0.7 - y3d * 0.3;
                var py = cy - z3d * 0.9 - y3d * 0.3;
                if (j === -1) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            }
            ctx.stroke();
        }
        ctx.globalAlpha = 1;
    }

    // --- Klein: wireframe classic bottle ---
    function drawKlein() {
        var s = setupCanvas('thumb-klein');
        if (!s) return;
        var ctx = s.ctx, w = s.w, h = s.h;
        var cx = w / 2, cy = h / 2 + 4;
        var PI = Math.PI;
        var scale = Math.min(w, h) * 0.022;

        ctx.strokeStyle = ACCENT;
        ctx.lineWidth = 0.8;

        function kleinPt(u, v) {
            var cosU = Math.cos(u), sinU = Math.sin(u);
            var cosV = Math.cos(v), sinV = Math.sin(v);
            var r = 4 * (1 - cosU / 2);
            var x3d, y3d, z3d;
            if (u < PI) {
                x3d = 6 * cosU * (1 + sinU) + r * cosU * cosV;
                y3d = 16 * sinU + r * sinU * cosV;
            } else {
                x3d = 6 * cosU * (1 + sinU) - r * cosV;
                y3d = 16 * sinU;
            }
            z3d = r * sinV;
            return {
                px: cx + (x3d * 0.85 + z3d * 0.2) * scale,
                py: cy - (y3d * 0.75 + z3d * 0.25) * scale
            };
        }

        // Longitudinal ribs (u-lines)
        ctx.globalAlpha = 0.5;
        for (var vi = 0; vi <= 6; vi++) {
            var v = (vi / 6) * 2 * PI;
            ctx.beginPath();
            for (var ui = 0; ui <= 200; ui++) {
                var u = (ui / 200) * 2 * PI;
                var pt = kleinPt(u, v);
                if (ui === 0) ctx.moveTo(pt.px, pt.py);
                else ctx.lineTo(pt.px, pt.py);
            }
            ctx.stroke();
        }

        // Cross-section rings (v-lines)
        ctx.globalAlpha = 0.25;
        for (var ui = 0; ui < 12; ui++) {
            var u = (ui / 12) * 2 * PI;
            ctx.beginPath();
            for (var vi2 = 0; vi2 <= 100; vi2++) {
                var v = (vi2 / 100) * 2 * PI;
                var pt = kleinPt(u, v);
                if (vi2 === 0) ctx.moveTo(pt.px, pt.py);
                else ctx.lineTo(pt.px, pt.py);
            }
            ctx.stroke();
        }
        ctx.globalAlpha = 1;
    }

    // --- Sierpinski: recursive triangle ---
    function drawSierpinski() {
        var s = setupCanvas('thumb-sierpinski');
        if (!s) return;
        var ctx = s.ctx, w = s.w, h = s.h;

        var pad = 20;
        var side = Math.min(w - pad * 2, (h - pad * 2) / (Math.sqrt(3) / 2));
        var ax = w / 2, ay = pad;
        var bx = w / 2 - side / 2, by = pad + side * Math.sqrt(3) / 2;
        var cx_t = w / 2 + side / 2, cy_t = by;

        ctx.fillStyle = ACCENT;
        ctx.globalAlpha = 0.75;

        function sierp(ax, ay, bx, by, cx, cy, depth) {
            if (depth === 0) {
                ctx.beginPath();
                ctx.moveTo(ax, ay);
                ctx.lineTo(bx, by);
                ctx.lineTo(cx, cy);
                ctx.closePath();
                ctx.fill();
                return;
            }
            var mABx = (ax + bx) / 2, mABy = (ay + by) / 2;
            var mBCx = (bx + cx) / 2, mBCy = (by + cy) / 2;
            var mACx = (ax + cx) / 2, mACy = (ay + cy) / 2;
            sierp(ax, ay, mABx, mABy, mACx, mACy, depth - 1);
            sierp(mABx, mABy, bx, by, mBCx, mBCy, depth - 1);
            sierp(mACx, mACy, mBCx, mBCy, cx, cy, depth - 1);
        }

        sierp(ax, ay, bx, by, cx_t, cy_t, 6);
        ctx.globalAlpha = 1;
    }

    // --- Mandelbrot: low-res fractal ---
    function drawMandelbrot() {
        var s = setupCanvas('thumb-mandelbrot');
        if (!s) return;
        var ctx = s.ctx, w = s.w, h = s.h, dpr = s.dpr;

        // Reset transform so putImageData works at physical pixel level
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        var pw = w * dpr, ph = h * dpr;
        var imgData = ctx.createImageData(pw, ph);
        var data = imgData.data;
        var cxM = -0.5, cyM = 0.0, zoomM = w / 3.5;
        var maxIter = 80;

        for (var py = 0; py < ph; py++) {
            for (var px = 0; px < pw; px++) {
                // Map physical pixel back to CSS coords, then to complex plane
                var x0 = cxM + (px / dpr - w / 2) / zoomM;
                var y0 = cyM + (py / dpr - h / 2) / zoomM;
                var x = 0, y = 0, xx = 0, yy = 0, iter = 0;

                while (xx + yy <= 4 && iter < maxIter) {
                    y = 2 * x * y + y0;
                    x = xx - yy + x0;
                    xx = x * x;
                    yy = y * y;
                    iter++;
                }

                var idx = (py * pw + px) * 4;
                if (iter === maxIter) {
                    // Inside the set: background
                    data[idx] = 16; data[idx + 1] = 16; data[idx + 2] = 16;
                } else {
                    // Smooth iteration for anti-banding
                    var log2 = Math.log(2);
                    var nu = Math.log(Math.log(Math.sqrt(xx + yy)) / log2) / log2;
                    var t = ((iter + 1 - nu) / maxIter * 6) % 1;
                    t = Math.max(0, Math.min(1, t));
                    var b = Math.pow(t, 0.7);
                    // Lerp from background (#101010) to accent (#c8a26a)
                    data[idx]     = Math.floor(16 + 184 * b);
                    data[idx + 1] = Math.floor(16 + 146 * b);
                    data[idx + 2] = Math.floor(16 + 90 * b);
                }
                data[idx + 3] = 255;
            }
        }
        ctx.putImageData(imgData, 0, 0);
    }

    // Render all thumbnails
    drawLorenz();
    drawMobius();
    drawKlein();
    drawSierpinski();
    drawMandelbrot();

})();
</script>

</body>
</html>
